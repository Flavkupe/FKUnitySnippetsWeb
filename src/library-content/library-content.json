[{"demoName":"ExtensionFunctions","fileContent":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\n\nnamespace FKUnitySnippets.ExtensionFunctions\n{\n    public static class ExtensionFunctions\n    {\n        public static void DestroyChildren(this Transform transform)\n        {\n            foreach (Transform child in transform)\n            {\n                UnityEngine.Object.Destroy(child.gameObject);\n            }\n        }\n    }\n\n    public static class Vector3Extensions\n    {\n        public static Vector3 MoveX(this Vector3 vector, float x)\n        {\n            return new Vector3(vector.x + x, vector.y, vector.z);\n        }\n\n        public static Vector3 SetX(this Vector3 vector, float x)\n        {\n            return new Vector3(x, vector.y, vector.z);\n        }\n\n        public static Vector3 SetY(this Vector3 vector, float y)\n        {\n            return new Vector3(vector.x, y, vector.z);\n        }\n\n        public static Vector3 ShiftY(this Vector3 vector, float y)\n        {\n            return new Vector3(vector.x, vector.y + y, vector.z);\n        }\n\n        public static Vector3 ShiftX(this Vector3 vector, float x)\n        {\n            return new Vector3(vector.x + x, vector.y, vector.z);\n        }\n\n        public static Vector3 ShiftXY(this Vector3 vector, float x, float y)\n        {\n            return new Vector3(vector.x + x, vector.y + y, vector.z);\n        }\n\n        public static Vector3 SetXY(this Vector3 vector, float x, float y)\n        {\n            return new Vector3(x, y, vector.z);\n        }\n\n        public static Vector3 SetZ(this Vector3 vector, float z)\n        {\n            return new Vector3(vector.x, vector.y, z);\n        }\n\n        public static bool IsWithinDistance(this Vector3 source, Vector3 target, float distance = 0.1f)\n        {\n            return Vector3.Distance(source, target) <= distance;\n        }\n    }\n\n    public static class RandomizationExtensions\n    {\n        /// <summary>\n        /// Gets a random value between the vector's x and y values.\n        /// This is especially useful when using a Vector2 to easily define a range\n        /// in the Inspector.\n        /// inclusive.\n        /// </summary>\n        public static float RandRange(this Vector2 vector)\n        {\n            return UnityEngine.Random.Range(vector.x, vector.y);\n        }\n    }\n\n    public static class ListExtensions\n    {\n        /// <summary>\n        /// Gets a random value from the list. If the list is empty, returns\n        /// the default value.\n        /// </summary>\n        public static TValue GetRandom<TValue>(this IList<TValue> list)\n        {\n            if (list == null || list.Count == 0)\n            {\n                return default;\n            }\n\n            var random = UnityEngine.Random.Range(0, list.Count);\n            return list[random];\n        }\n\n        /// <summary>\n        /// Shuffles the provided list. Returns the same instance of the list, shuffled.\n        /// </summary>\n        public static IList<TValue> GetShuffled<TValue>(this IList<TValue> list)\n        {\n            for (int i = 0; i < list.Count; i++)\n            {\n                var randomIndex = UnityEngine.Random.Range(0, list.Count - 1);\n                var temp = list[i];\n                list[i] = list[randomIndex];\n                list[randomIndex] = temp;\n            }\n\n            return list;\n        }\n\n        /// <summary>\n        /// Gets the element that has the maximum value from the provided predicate (as opposed\n        /// to just fetching the value itself, which is what LINQ's Max() does).\n        /// </summary>\n        public static T WithMaxValue<T, R>(this IList<T> source, Func<T, R> predicate) where R : IComparable\n        {\n            if (source.Count() == 0)\n            {\n                return default;\n            }\n\n            var max = source[0];\n            var maxValue = predicate(max);\n            foreach (var item in source)\n            {\n                var value = predicate(item);\n                if (maxValue == null || value.CompareTo(maxValue) > 0)\n                {\n                    maxValue = value;\n                    max = item;\n                }\n            }\n\n            return max;\n        }\n\n\n        /// <summary>\n        /// Gets the element that has the minimum value from the provided predicate (as opposed\n        /// to just fetching the value itself, which is what LINQ's Min() does).\n        /// </summary>\n        public static T WithMinValue<T, R>(this IList<T> source, Func<T, R> predicate) where R : IComparable\n        {\n            if (source.Count() == 0)\n            {\n                return default;\n            }\n\n            var min = source[0];\n            var minValue = predicate(min);\n            foreach (var item in source)\n            {\n                var value = predicate(item);\n                if (minValue == null || value.CompareTo(minValue) < 0)\n                {\n                    minValue = value;\n                    min = item;\n                }\n            }\n\n            return min;\n        }\n    }\n\n    public static class DictionaryExtensions\n    {\n        public static R GetValueOrDefault<T, R>(this IDictionary<T, R> dict, T key)\n        {\n            if (dict.ContainsKey(key))\n            {\n                return dict[key];\n            }\n\n            return default;\n        }\n\n        /// <summary>\n        /// Sets the value of the key in the dictionary, or adds to that value if the\n        /// value already exists.\n        /// </summary>\n        public static void SetOrAddTo<T>(this IDictionary<T, int> dict, T key, int val)\n        {\n            if (!dict.ContainsKey(key))\n            {\n                dict[key] = val;\n            }\n            else\n            {\n                dict[key] += val;\n            }\n        }\n    }\n}","name":"ExtensionFunctions","category":"ExtensionFunctions","shortPath":"ExtensionFunctions","filename":"ExtensionFunctions.cs","path":"ExtensionFunctions/ExtensionFunctions.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/ExtensionFunctions/ExtensionFunctions.cs","docFileContent":"### Extension Functions\nExtension Functions can save you a ton of time and effort writing code. If you are not familiar with the concept, an Extension Function basically allows you to define a method that you can use on any class that exists, even one you didn't write yourself (in fact, this is the most likely application of it).\n\nThe library `System.Linq` includes a bunch of very useful extension functions that you can use on any `IEnumerable` object such as `List`. The `ExtensionFunctions.cs` file similarly includes a bunch of ExtensionFunctions I've accumulated over time for various Unity projects.\n\nIf you aren't familiar with the usage of extension functions, here's an example of how you'd use `MoveX` on a Vector3 object (**NOTE: don't forget to include the namespace that the Extension Functions are in!):\n\n~~~csharp\nusing UnityEngine;\n\n// IMPORTANT: Make sure to include the namespace of the Extension Functions!\nusing FKUnitySnippets.ExtensionFunctions;\n\npublic class Example : MonoBehaviour\n{\n\tvoid Start()\n\t{\n\t\tVector3 position = new Vector3(1, 2, 3);\n\t\tposition = position.MoveX(5);\n\t\tDebug.Log(position); // Output: (5, 2, 3)\n\t}\n}\n~~~\n\nYou can always create your own Extension functions as well. Here's an example of how you'd create an Extension Function for the `Vector3` class:\n\n~~~csharp\nusing UnityEngine;\n\npublic static class MyVector3Extensions\n{\n\t// this operates on a Vector3 object and takes x as an argument\n\tpublic static Vector3 MyExtensionFunction(this Vector3 vector, float x)\n\t{\n\t\t// do something with the vector\n\t}\n}\n~~~","supportingFiles":[],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/ExtensionFunctions/ExtensionFunctions.unitypackage","packageFileName":"ExtensionFunctions.unitypackage"},{"demoName":"ShakyText","fileContent":"using UnityEngine;\nusing System.Collections;\nusing TMPro;\n\nnamespace FKUnitySnippets.Text.TMPro\n{\n    /// <summary>\n    /// This is adapted from the VertexJitter script in the TextMesh Pro extensions\n    /// examples. This one allows for more configuration and allows the text to change\n    /// dynamically, and for the jitter effect to be started and stopped.\n    /// </summary>\n    [RequireComponent(typeof(TMP_Text))]\n    public class ShakyText : MonoBehaviour\n    {\n        [SerializeField]\n        private float _angleMultiplier = 1.0f;\n\n        [SerializeField]\n        private float _curveScale = 1.0f;\n\n        private TMP_Text _textComponent;\n\n        private bool hasTextChanged;\n\n        [SerializeField]\n        private bool _autoStart = false;\n\n        private Coroutine _jitterRoutine;\n\n        /// <summary>\n        /// Structure to hold pre-computed animation data.\n        /// </summary>\n        private struct VertexAnim\n        {\n            public float angleRange;\n            public float angle;\n            public float speed;\n        }\n\n        void Awake()\n        {\n            _textComponent = GetComponent<TMP_Text>();\n        }\n\n        void OnEnable()\n        {\n            // Subscribe to event fired when text object has been regenerated.\n            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);\n        }\n\n        void OnDisable()\n        {\n            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);\n        }\n\n\n        void Start()\n        {\n            if (_autoStart)\n            {\n                _jitterRoutine = StartCoroutine(AnimateVertexColors());\n            }\n        }\n\n        public void StartJitter()\n        {\n            if (!this.gameObject.activeInHierarchy)\n            {\n                return;\n            }\n\n            if (_jitterRoutine != null)\n            {\n                StopCoroutine(_jitterRoutine);\n            }\n\n            _jitterRoutine = StartCoroutine(AnimateVertexColors());\n        }\n\n        public void StopJitter()\n        {\n            if (_jitterRoutine == null)\n            {\n                return;\n            }\n\n            StopCoroutine(_jitterRoutine);\n            _jitterRoutine = null;\n        }\n\n\n        void ON_TEXT_CHANGED(Object obj)\n        {\n            if (obj == _textComponent)\n            {\n                hasTextChanged = true;\n            }\n        }\n\n        /// <summary>\n        /// Method to animate vertex colors of a TMP Text object.\n        /// </summary>\n        /// <returns></returns>\n        IEnumerator AnimateVertexColors()\n        {\n\n            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.\n            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.\n            _textComponent.ForceMeshUpdate();\n\n            TMP_TextInfo textInfo = _textComponent.textInfo;\n\n            Matrix4x4 matrix;\n\n            int loopCount = 0;\n            hasTextChanged = true;\n\n            // Create an Array which contains pre-computed Angle Ranges and Speeds for a bunch of characters.\n            VertexAnim[] vertexAnim = new VertexAnim[1024];\n            for (int i = 0; i < 1024; i++)\n            {\n                vertexAnim[i].angleRange = Random.Range(10f, 25f);\n                vertexAnim[i].speed = Random.Range(1f, 3f);\n            }\n\n            // Cache the vertex data of the text object as the Jitter FX is applied to the original position of the characters.\n            TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData();\n\n            while (true)\n            {\n                // Get new copy of vertex data if the text has changed.\n                if (hasTextChanged)\n                {\n                    // Update the copy of the vertex data for the text object.\n                    cachedMeshInfo = textInfo.CopyMeshInfoVertexData();\n\n                    hasTextChanged = false;\n                }\n\n                int characterCount = textInfo.characterCount;\n\n                // If No Characters then just yield and wait for some text to be added\n                if (characterCount == 0)\n                {\n                    yield return new WaitForSeconds(0.25f);\n                    continue;\n                }\n\n\n                for (int i = 0; i < characterCount; i++)\n                {\n                    TMP_CharacterInfo charInfo = textInfo.characterInfo[i];\n\n                    // Skip characters that are not visible and thus have no geometry to manipulate.\n                    if (!charInfo.isVisible)\n                        continue;\n\n                    // Retrieve the pre-computed animation data for the given character.\n                    VertexAnim vertAnim = vertexAnim[i];\n\n                    // Get the index of the material used by the current character.\n                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;\n\n                    // Get the index of the first vertex used by this text element.\n                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;\n\n                    // Get the cached vertices of the mesh used by this text element (character or sprite).\n                    Vector3[] sourceVertices = cachedMeshInfo[materialIndex].vertices;\n\n                    // Determine the center point of each character at the baseline.\n                    //Vector2 charMidBasline = new Vector2((sourceVertices[vertexIndex + 0].x + sourceVertices[vertexIndex + 2].x) / 2, charInfo.baseLine);\n                    // Determine the center point of each character.\n                    Vector2 charMidBasline = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2;\n\n                    // Need to translate all 4 vertices of each quad to aligned with middle of character / baseline.\n                    // This is needed so the matrix TRS is applied at the origin for each character.\n                    Vector3 offset = charMidBasline;\n\n                    Vector3[] destinationVertices = textInfo.meshInfo[materialIndex].vertices;\n\n                    destinationVertices[vertexIndex + 0] = sourceVertices[vertexIndex + 0] - offset;\n                    destinationVertices[vertexIndex + 1] = sourceVertices[vertexIndex + 1] - offset;\n                    destinationVertices[vertexIndex + 2] = sourceVertices[vertexIndex + 2] - offset;\n                    destinationVertices[vertexIndex + 3] = sourceVertices[vertexIndex + 3] - offset;\n\n                    vertAnim.angle = Mathf.SmoothStep(-vertAnim.angleRange, vertAnim.angleRange, Mathf.PingPong(loopCount / 25f * vertAnim.speed, 1f));\n                    Vector3 jitterOffset = new Vector3(Random.Range(-.25f, .25f), Random.Range(-.25f, .25f), 0);\n\n                    matrix = Matrix4x4.TRS(jitterOffset * _curveScale, Quaternion.Euler(0, 0, Random.Range(-5f, 5f) * _angleMultiplier), Vector3.one);\n\n                    destinationVertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 0]);\n                    destinationVertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 1]);\n                    destinationVertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 2]);\n                    destinationVertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 3]);\n\n                    destinationVertices[vertexIndex + 0] += offset;\n                    destinationVertices[vertexIndex + 1] += offset;\n                    destinationVertices[vertexIndex + 2] += offset;\n                    destinationVertices[vertexIndex + 3] += offset;\n\n                    vertexAnim[i] = vertAnim;\n                }\n\n                // Push changes into meshes\n                for (int i = 0; i < textInfo.meshInfo.Length; i++)\n                {\n                    textInfo.meshInfo[i].mesh.vertices = textInfo.meshInfo[i].vertices;\n                    _textComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);\n                }\n\n                loopCount += 1;\n\n                yield return new WaitForSeconds(0.1f);\n            }\n        }\n    }\n}","name":"ShakyText","category":"Text/TMPro","shortPath":"Text/TMPro/ShakyText","filename":"ShakyText.cs","path":"Text/TMPro/ShakyText/ShakyText.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Text/TMPro/ShakyText/ShakyText.cs","docFileContent":"### Shaky Text\nThis is a simple modification of Unity's own VertexJitter script which comes with the TMPro Extensions & Examples package. This modification makes it a bit easier to use for this purpose.","supportingFiles":[],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Text/TMPro/ShakyText/ShakyText.unitypackage","packageFileName":"ShakyText.unitypackage"},{"demoName":"OscillatingObject","fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Transformations\n{\n    public class OscillatingObject : MonoBehaviour\n    {\n        private float _period = 0.0f;\n\n        [SerializeField]\n        private float _speed = 1.0f;\n\n        [SerializeField]\n        private float _magnitude = 1.0f;\n\n        [SerializeField]\n        private Vector3 _axis = Vector3.up;\n\n        private Vector3 _originalPos;\n\n        public void ResetState()\n        {\n            this.transform.localPosition = _originalPos;\n            _period = 0.0f;\n        }\n\n        void Start()\n        {\n            _originalPos = this.transform.localPosition;\n        }\n\n        // Update is called once per frame\n        void Update()\n        {\n            _period = (_period + _speed * Time.deltaTime) % (2 * Mathf.PI);\n\n            var cos = Mathf.Abs(Mathf.Cos(_period) * _magnitude);\n            this.transform.localPosition = _originalPos + this._axis * cos;\n        }\n    }\n}","name":"OscillatingObject","category":"Transformations","shortPath":"Transformations/OscillatingObject","filename":"OscillatingObject.cs","path":"Transformations/OscillatingObject/OscillatingObject.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Transformations/OscillatingObject/OscillatingObject.cs","docFileContent":"### Oscillating Object\nUsing functions like *sin* or *cos* is a good way to make object \"wavering\" movement like this look smooth.","supportingFiles":[],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Transformations/OscillatingObject/OscillatingObject.unitypackage","packageFileName":"OscillatingObject.unitypackage"},{"demoName":"SpinningObject","fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Transformations\n{\n    public class SpinningObject : MonoBehaviour\n    {\n        [SerializeField]\n        private float _rotationSpeed = 1f;\n\n        [SerializeField]\n        private Vector3 _axis = Vector3.up;\n\n        private Quaternion _originalRotation;\n\n        private void Start()\n        {\n            _originalRotation = transform.rotation;\n        }\n\n        private void Update()\n        {\n            transform.Rotate(_axis, _rotationSpeed * Time.deltaTime);\n        }\n\n        public void ResetState()\n        {\n            transform.rotation = _originalRotation;\n        }\n    }\n}\n","name":"SpinningObject","category":"Transformations","shortPath":"Transformations/SpinningObject","filename":"SpinningObject.cs","path":"Transformations/SpinningObject/SpinningObject.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Transformations/SpinningObject/SpinningObject.cs","docFileContent":"### Spinning Object\nThis extremely simple script seems trivial, but it can be used creatively in many ways. See the various demos to see how you can:\n\n1. Make an object spin at variable speeds.\n2. Spin various objects around an object.\n3. Spin a 2D object around the Y axis to have a \"spinning coin\" effect common in 2D platformers.","supportingFiles":[],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Transformations/SpinningObject/SpinningObject.unitypackage","packageFileName":"SpinningObject.unitypackage"},{"demoName":"FadingObject","fileContent":"using System.Collections;\nusing UnityEngine;\n\nnamespace FKUnitySnippets.Transformations\n{\n    public class FadingObject : MonoBehaviour\n    {\n        [Tooltip(\"How quickly the object will fade out.\")]\n        [SerializeField]\n        private float _fadeSpeed = 1f;\n\n        [Tooltip(\"If true, the object will be destroyed when fully faded out.\")]\n        [SerializeField]\n        private bool _destroyOnFadeOut = false;\n\n        [Tooltip(\"If true, the object will fade out automatically on start.\")]\n        [SerializeField]\n        private bool _autoFadeOut = true;\n\n        private Coroutine _coroutine;\n\n        private Material _material;\n        private Color _originalColor;\n\n        private void Start()\n        {\n            _material = GetComponent<Renderer>().material;\n            _originalColor = _material.color;\n\n            if (_autoFadeOut)\n            {\n                FadeOut();\n            }\n        }\n\n        public void FadeOut()\n        {\n            StopFade();\n\n            _coroutine = StartCoroutine(FadeOutCoroutine());\n        }\n\n        public void FadeIn()\n        {\n            StopFade();\n\n            _coroutine = StartCoroutine(FadeInCoroutine());\n        }\n\n        public void StopFade()\n        {\n            if (_coroutine != null)\n            {\n                StopCoroutine(_coroutine);\n            }\n        }\n\n        public void ResetState()\n        {\n            StopFade();\n            _material.color = _originalColor;\n            if (_autoFadeOut)\n            {\n                FadeOut();\n            }\n        }\n\n        private IEnumerator FadeOutCoroutine()\n        {\n            while (_material.color.a > 0)\n            {\n                var c = _material.color;\n                _material.color = new Color(c.r, c.g, c.b, c.a - _fadeSpeed * Time.deltaTime);\n                yield return null;\n            }\n\n            if (_destroyOnFadeOut)\n            {\n                Destroy(gameObject);\n            }\n        }\n\n        private IEnumerator FadeInCoroutine()\n        {\n            while (_material.color.a < 1)\n            {\n                var c = _material.color;\n                _material.color = new Color(c.r, c.g, c.b, c.a + _fadeSpeed * Time.deltaTime);\n                yield return null;\n            }\n        }\n    }\n}","name":"FadingObject","category":"Transformations","shortPath":"Transformations/FadingObject","filename":"FadingObject.cs","path":"Transformations/FadingObject/FadingObject.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Transformations/FadingObject/FadingObject.cs","docFileContent":"### FadingObject\nA commonly used script for making things disappear slowly. Used this for text that should fade out after some time, or for enemies that died, to make them disappear more smoothly.\n\nThere is an option for destroying the object after fading out, to make it easier to destroy objects that have fully faded. However, note that if you use this you will not be able to fade them back in.","supportingFiles":[],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Transformations/FadingObject/FadingObject.unitypackage","packageFileName":"FadingObject.unitypackage"},{"demoName":"ShiftingObject","fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Transformations\n{\n    public class ShiftingObject : MonoBehaviour\n    {\n        [SerializeField]\n        private float _speed = 1f;\n\n        [SerializeField]\n        private Vector3 _direction = Vector3.up;\n\n\n        private Vector3 _startPosition;\n\n\n        private void Start()\n        {\n            _startPosition = transform.position;\n        }\n\n        public void Update()\n        {\n            transform.position += _direction * _speed * Time.deltaTime;\n        }\n\n        public void ResetState()\n        {\n            transform.position = _startPosition;\n        }\n    }\n}","name":"ShiftingObject","category":"Transformations","shortPath":"Transformations/ShiftingObject","filename":"ShiftingObject.cs","path":"Transformations/ShiftingObject/ShiftingObject.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Transformations/ShiftingObject/ShiftingObject.cs","docFileContent":"### ShiftingObject\nIt's just an object that floats straight up. Or sideways, or some other direction. But in a 2D game, it'll usually be up. This is a simple script but I have found it to be extremely common to need this for all sorts of stuff.\n\nIt's particularly useful for text, and when mixed with the FadingObject script to make the text fade as it floats up.","supportingFiles":[],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Transformations/ShiftingObject/ShiftingObject.unitypackage","packageFileName":"ShiftingObject.unitypackage"},{"demoName":"Bezier","fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Curves\n{\n    public class BezierDemo : MonoBehaviour\n    {\n        [Tooltip(\"Which object is moving along the curve.\")]\n        [SerializeField]\n        private GameObject _targetObject;\n\n        [Tooltip(\"End point of the curve.\")]\n        [SerializeField]\n        private Vector3 _targetPoint;\n\n        [Tooltip(\"Starting point of the curve.\")]\n        [SerializeField]\n        private Vector3 _startingPoint;\n\n        [Tooltip(\"How far up (or down, if negative) the middle of the curve is.\")]\n        [SerializeField]\n        private float _controlPointOffset = 0.0f;\n\n        [Tooltip(\"Travel speed of object.\")]\n        [SerializeField]\n        private float _speed = 1.0f;\n\n        [Tooltip(\"If true, the object will rotate in the direction of movement.\")]\n        [SerializeField]\n        private bool _turnInMovementDirection = true;\n\n        [Tooltip(\"If true, the position will reset to the starting point when the target is reached.\")]\n        [SerializeField]\n        private bool _looping = true;\n\n        private float _t = 0.0f;\n\n        private Bezier _bezier;\n\n        private void Start()\n        {\n            ResetState();   \n        }\n\n        public void ResetState()\n        {\n            _t = 0.0f;\n            var midpoint = (_startingPoint + _targetPoint) / 2;\n            _bezier = new Bezier(_startingPoint, midpoint + Vector3.up * _controlPointOffset, _targetPoint);\n        }\n\n        public void Reverse()\n        {\n            _speed *= -1;\n        }\n\n        private void Update()\n        {\n            // this allows _speed to change to negative to reverse the direction\n            // after the destination is reached\n            var t = _t + Time.deltaTime * _speed;\n            if (t < 0.0f || t > 1.0f)\n            {\n                if (_looping)\n                {\n                    ResetState();\n                }\n\n                return;\n            }\n\n            _t = t;\n            var point = _bezier.GetPoint(_t);\n            _targetObject.transform.position = point;\n\n            if (_turnInMovementDirection)\n            {\n                Vector3 direction = _bezier.GetDirection(_t);\n                float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;\n                _targetObject.transform.rotation = Quaternion.Euler(new Vector3(0, 0, angle));\n\n                // NOTE: The following also works the same as above; however, due to how Quaternion.LookRotation works,\n                // it requires the additional rotation below to make it work properly in 2D.\n                // _targetObject.rotation = Quaternion.LookRotation(_bezier.GetDirection(_t));\n                // _targetObject.Rotate(0, 90, 180);\n            }\n        }\n    }\n}\n","name":"Bezier","category":"Curves","shortPath":"Curves/Bezier","filename":"BezierDemo.cs","path":"Curves/Bezier/BezierDemo.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Curves/Bezier/BezierDemo.cs","docFileContent":"### Bezier Curves\nYou can use Bezier curves to represent an \"arc\", like an arrow shooting up and back down. You can get a similar parabolic effect by using physics and gravity, but Bezier curves are simple and effective ways to plot the trajectory of an object through an arc.\n\nThe basic things about the `Bezier.cs` script:\n\n1. The object goes from `_t` == 0.0f (start point) to `_t` == 1.0f (end point). The speed at which `_t` goes up indicates how quickly the object moves.\n2. There are 3 `Vector3` points defining the curve: `p0`, `p1` and `p2`. `p0` is the start point and `p2` is the end point. `p1` is some point in the middle that determines how far up or down the object will curve. It doesn't need to be at the midpoint between `p0` and `p2`, though this Demo script uses that to make a symmetrical arc.\n3. You can use the derivative of the arc to make the object point in the direction that it is facing. This Demo uses this to make the arrow point in the correct direction.","supportingFiles":[{"demoName":"Bezier","fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Curves\n{\n    public class Bezier\n    {\n        private Vector3 p0;\n        private Vector3 p1;\n        private Vector3 p2;\n\n        public Bezier(Vector3 p0, Vector3 p1, Vector3 p2)\n        {\n            this.p0 = p0;\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n\n        public Vector3 GetPoint(float t)\n        {\n            t = Mathf.Clamp01(t);\n            float oneMinusT = 1.0f - t;\n            return oneMinusT * oneMinusT * p0 +\n                2f * oneMinusT * t * p1 +\n                t * t * p2;\n        }\n\n        public Vector3 GetFirstDerivative(float t)\n        {\n            return 2f * (1f - t) * (p1 - p0) + 2f * t * (p2 - p1);\n        }\n\n        public Vector3 GetVelocity(Transform transform, float t)\n        {\n            return transform.TransformPoint(this.GetFirstDerivative(t)) - transform.position;\n        }\n\n        public Vector3 GetDirection(Transform transform, float t)\n        {\n            return GetVelocity(transform, t).normalized;\n        }\n\n        public Vector3 GetDirection(float t)\n        {\n            return GetFirstDerivative(t).normalized;\n        }\n    }\n}","name":"Bezier","category":"Curves","shortPath":"Curves/Bezier","filename":"Bezier.cs","path":"Curves/Bezier/Bezier.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Curves/Bezier/Bezier.cs","docFileContent":null,"supportingFiles":[]}],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Curves/Bezier/Bezier.unitypackage","packageFileName":"Bezier.unitypackage"},{"demoName":"CatmullRomSpline","fileContent":"using FKUnitySnippets.Curves;\nusing UnityEngine;\nusing System.Linq;\n\npublic class CatmullRomSplineDemo : MonoBehaviour\n{\n    [SerializeField]\n    private Transform[] _controlPoints;\n\n    [SerializeField]\n    private GameObject _pointPrefab;\n\n    [SerializeField]\n    private GameObject _object;\n\n    [SerializeField]\n    private float _speed = 1.0f;\n\n    private CatmullRomSpline _spline;\n\n    private float _t = 0.0f;\n\n    private void Start()\n    {\n        var points = _controlPoints.Select(cp => cp.position);\n        _spline = new CatmullRomSpline(points);\n    }\n\n    public void AddPoint(Vector3 point)\n    {\n        point = new Vector3(point.x, point.y, 0.0f);\n        _spline.AddPoint(point);\n        var newPoint = Instantiate(_pointPrefab, this.transform, true);\n        newPoint.transform.position = point;\n\n        var text = _spline.PointCount.ToString();\n        newPoint.GetComponentInChildren<TextMesh>().text = text;\n        newPoint.name = text;\n    }\n\n    private void Update()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            var point = Camera.main.ScreenToWorldPoint(Input.mousePosition);\n            AddPoint(point);\n            _t = 0.0f;\n            return;\n        }\n\n        // divide by point count so that the speed is normalized as more points are\n        // added; otherwise adding more points causes the object to move faster since the\n        // interpolation is still between 0.0 to 1.0.\n        _t += (_speed * Time.deltaTime) / (_spline.PointCount - 2);\n        if (_t > 1.0f)\n        {\n            _t = 0.0f;\n        }\n\n        _object.transform.position = _spline.GetPoint(_t);\n    }\n}\n","name":"CatmullRomSpline","category":"Curves","shortPath":"Curves/CatmullRomSpline","filename":"CatmullRomSplineDemo.cs","path":"Curves/CatmullRomSpline/CatmullRomSplineDemo.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Curves/CatmullRomSpline/CatmullRomSplineDemo.cs","docFileContent":"### Catmull-Rom Spline\nA popular spline commonly used in animation for smooth interpolation between points.\n\nAs setup in this demo, a segment of the spline has 4 points (p0, p1, p2 and p3), and the spline is calculated only between p1 and p2, with p0 and p3 as control points. By adding additional points, it will smoothly travel between them, though notably it will never hit this first and last points in the list.\n\nThis spline is very useful for creating smooth paths for objects (including cameras) to follow, and is used in many games and animations.","supportingFiles":[{"demoName":"CatmullRomSpline","fileContent":"using System.Collections.Generic;\nusing UnityEngine;\nusing System.Linq;\n\nnamespace FKUnitySnippets.Curves\n{\n    public class CatmullRomSpline\n    {\n        private List<Vector3> _points = new();\n\n        public int PointCount => _points.Count;\n\n        public CatmullRomSpline(IEnumerable<Vector3> points)\n        {\n            this._points = points.ToList();\n        }\n\n        public void AddPoint(Vector3 point)\n        {\n            _points.Add(point);\n        }\n\n        public Vector3 GetPoint(float t)\n        {\n            int numSections = _points.Count - 3;\n            int currPoint = Mathf.Min(Mathf.FloorToInt(t * numSections), numSections - 1);\n            float u = t * numSections - currPoint;\n\n            Vector3 a = _points[currPoint];\n            Vector3 b = _points[currPoint + 1];\n            Vector3 c = _points[currPoint + 2];\n            Vector3 d = _points[currPoint + 3];\n\n            return 0.5f * (\n                (-a + 3f * b - 3f * c + d) * (u * u * u) +\n                (2f * a - 5f * b + 4f * c - d) * (u * u) +\n                (-a + c) * u +\n                2f * b\n            );\n        }\n    }\n}","name":"CatmullRomSpline","category":"Curves","shortPath":"Curves/CatmullRomSpline","filename":"CatmullRomSpline.cs","path":"Curves/CatmullRomSpline/CatmullRomSpline.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Curves/CatmullRomSpline/CatmullRomSpline.cs","docFileContent":null,"supportingFiles":[]}],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Curves/CatmullRomSpline/CatmullRomSpline.unitypackage","packageFileName":"CatmullRomSpline.unitypackage"},{"demoName":"Timer","fileContent":"using TMPro;\nusing UnityEngine;\n\nnamespace FKUnitySnippets.Coroutines\n{\n    public class TimerDemo : MonoBehaviour\n    {\n        [SerializeField]\n        private GameObject _objectToSpawn;\n\n        private Coroutine _intervalCoroutine;\n\n        [SerializeField]\n        private TMP_Text _intervalText;\n\n        [SerializeField]\n        private float _delayTime = 1.0f;\n\n        public void SpawnObjectNow()\n        {\n            Instantiate(_objectToSpawn);\n        }\n\n        public void SpawnObjectSoon()\n        {\n            // this works as well, but showing both options for illustration purposes:\n            // Timer.Instance.SetTimeout(SpawnObjectNow, 2.0f);\n\n            Timer.Instance.SetTimeout(() =>\n            {\n                Instantiate(_objectToSpawn);\n            }, _delayTime);\n        }\n\n        public void StartSpawningObjects()\n        {\n            // stop existing interval if it exists to avoid\n            // multiple intervals running at the same time\n            StopSpawningObjects();\n\n            _intervalText.text = \"Stop Spawning\";\n            _intervalCoroutine = Timer.Instance.SetInterval(() =>\n            {\n                Instantiate(_objectToSpawn);\n            }, _delayTime);\n        }\n\n        public void StopSpawningObjects()\n        {\n            if (_intervalCoroutine != null)\n            {\n                // IMPORTANT: make sure you call StopCoroutine from the same\n                // object that started the coroutine. If you don't, you will get errors!\n                Timer.Instance.StopCoroutine(_intervalCoroutine);\n                _intervalCoroutine = null;\n                _intervalText.text = \"Spawn Repeatedly\";\n            }\n        }\n\n        public void ToggleIntervalSpawns()\n        {\n            if (_intervalCoroutine == null)\n            {\n                StartSpawningObjects();\n            }\n            else\n            {\n                StopSpawningObjects();\n            }\n        }\n\n        void OnDestroy()\n        {\n            StopSpawningObjects();\n        }\n    }\n}\n","name":"Timer","category":"Coroutines","shortPath":"Coroutines/Timer","filename":"TimerDemo.cs","path":"Coroutines/Timer/TimerDemo.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Coroutines/Timer/TimerDemo.cs","docFileContent":"### Timer\nThis timer implementation gives you some very handy utility functions to create delayed or repeated actions.\n\n- `SetTimeout` allows you to configure a delayed action.\n- `SetInterval` allows you to configure a repeated action.\n- `DoNextFrame` is a more niche helper that can be very useful in specific cases.\n\nThe demo also shows how you can cancel a repeated action.\n\nYou might wonder why this needs to be a MonoBehaviour? This is because Coroutines must be started from MonoBehaviour instances. However, this doesn't *need* to be a Singleton; a Timer can be attached to each component that needs one. You can also create a static implementation of this which passes the source MonoBehaviour into each of the methods and starts the Coroutines from there.\n\nYou can also design this to not use Coroutines at all, though using Coroutines for this is very clean and simple.\n","supportingFiles":[{"demoName":"Timer","fileContent":"using System;\nusing System.Collections;\nusing UnityEngine;\n\nnamespace FKUnitySnippets.Coroutines\n{\n    public class Timer : MonoBehaviour\n    {\n        private static Timer _instance;\n\n        public static Timer Instance\n        {\n            get\n            {\n                if (_instance == null)\n                {\n                    _instance = new GameObject(\"Timer\").AddComponent<Timer>();\n                }\n\n                return _instance;\n            }\n        }\n\n        /// <summary>\n        /// Sets an action to start after `delay` seconds.\n        /// </summary>\n        /// <param name=\"action\">The action.</param>\n        /// <param name=\"delay\">Seconds to wait until the action.</param>\n        /// <returns></returns>\n        public Coroutine SetTimeout(Action action, float delay)\n        {\n            return StartCoroutine(TimeoutCoroutine(action, delay));\n        }\n\n        /// <summary>\n        /// Sets up an action to be called consistently every `interval` seconds.\n        /// </summary>\n        /// <param name=\"action\">The action to run.</param>\n        /// <param name=\"interval\">Time between actions, in seconds.</param>\n        public Coroutine SetInterval(Action action, float interval)\n        {\n            return StartCoroutine(IntervalCoroutine(action, interval));\n        }\n\n        /// <summary>\n        /// Does the action in the next frame. This is a bit of a hack but there\n        /// are times where it's quite useful. One example is when you know things will\n        /// load this frame and you want to wait for those things to load before doing\n        /// something (though it's best to setup proper event system for those scenarios).\n        /// </summary>\n        public void DoNextFrame(Action action)\n        {\n            StartCoroutine(DoNextFrameCoroutine(action));\n        }\n\n        private IEnumerator DoNextFrameCoroutine(Action action)\n        {\n            yield return null;\n            action();\n        }\n\n        private IEnumerator TimeoutCoroutine(Action action, float delay)\n        {\n            yield return new WaitForSeconds(delay);\n            action();\n        }\n\n        private IEnumerator IntervalCoroutine(Action action, float interval)\n        {\n            while (true)\n            {\n                yield return new WaitForSeconds(interval);\n                action();\n            }\n        }\n    }\n}","name":"Timer","category":"Coroutines","shortPath":"Coroutines/Timer","filename":"Timer.cs","path":"Coroutines/Timer/Timer.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Coroutines/Timer/Timer.cs","docFileContent":null,"supportingFiles":[]}],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Coroutines/Timer/Timer.unitypackage","packageFileName":"Timer.unitypackage"},{"demoName":"CoroutineRunner","fileContent":"using System.Collections;\nusing UnityEngine;\n\nnamespace FKUnitySnippets.Coroutines\n{\n    public class CoroutineRunner : MonoBehaviour\n    {\n        private static CoroutineRunner _instance;\n\n        public static CoroutineRunner Instance\n        {\n            get\n            {\n                if (_instance == null)\n                {\n                    GameObject runner = new GameObject(\"CoroutineRunner\");\n                    _instance = runner.AddComponent<CoroutineRunner>();\n                    DontDestroyOnLoad(runner);\n                }\n                return _instance;\n            }\n        }\n\n        public void RunCoroutine(IEnumerator coroutine)\n        {\n            StartCoroutine(coroutine);\n        }\n    }\n}\n","name":"CoroutineRunner","category":"Coroutines","shortPath":"Coroutines/Runner","filename":"CoroutineRunner.cs","path":"Coroutines/Runner/CoroutineRunner.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Coroutines/Runner/CoroutineRunner.cs","docFileContent":"### Coroutine Runner\nIf you're a fan of using Coroutines, the `CoroutineRunner` gives you a way to run a coroutine from classes that are not `MonoBehaviour`.\n\nHere's an example:\n\n~~~csharp\npublic static class MyUtilityClass\n{\n\tpublic static void DoSomething()\n\t{\n\t\tCoroutineRunner.Instance.RunCoroutine(MyCoroutine());\n\t}\n\n\tprivate static IEnumerator MyCoroutine()\n\t{\n\t\tyield return new WaitForSeconds(1f);\n\t\tDebug.Log(\"Coroutine finished!\");\n\t}\n}\n~~~\n","supportingFiles":[],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Coroutines/Runner/CoroutineRunner.unitypackage","packageFileName":"CoroutineRunner.unitypackage"},{"demoName":"WeightedList","fileContent":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\nusing UnityEngine.UI;\n\nnamespace FKUnitySnippets.Randomization\n{\n    [Serializable]\n    public class WeightedItem\n    {\n        public string Name;\n        public float Weight = 1.0f;\n        public Sprite Icon;\n    }\n\n    public class WeightedListDemo : MonoBehaviour\n    {\n        private WeightedList<WeightedItem> _weightedList;\n\n        [SerializeField]\n        private WeightedItem[] _items;\n\n        private LayoutGroup _resultDisplay;\n\n        private void Start()\n        {\n            var items = _items.Select(_items => new WeightedEntry<WeightedItem> { Item = _items, Weight = _items.Weight });\n            _weightedList = new WeightedList<WeightedItem>(items);\n\n            _resultDisplay = GetComponentInChildren<LayoutGroup>();\n        }\n\n        public void GenerateItems(bool weighted)\n        {\n            DestroyChildren(_resultDisplay.transform);\n            var items = new List<WeightedItem>();\n            for (var i = 0; i < 100; i++)\n            {\n                if (weighted)\n                {\n                    items.Add(_weightedList.GetWeightedRandomItem());\n                }\n                else\n                {\n                    items.Add(_weightedList.GetRandomItem());\n                }\n                \n            }\n\n            // sort by weight (ascending)\n            items.Sort((a, b) => (int)(a.Weight - b.Weight));\n\n            // add icons to the layout for the items being displayed\n            foreach (var item in items)\n            {\n                var itemObject = new GameObject(item.Name);\n                var image = itemObject.AddComponent<Image>();\n                image.sprite = item.Icon;\n                itemObject.transform.SetParent(_resultDisplay.transform);\n            }\n        }\n\n        public void DestroyChildren(Transform transform)\n        {\n            foreach (Transform child in transform)\n            {\n                if (child != null)\n                {\n                    UnityEngine.Object.Destroy(child.gameObject);\n                }\n            }\n        }\n    }\n}\n","name":"WeightedList","category":"Randomization","shortPath":"Randomization/WeightedList","filename":"WeightedListDemo.cs","path":"Randomization/WeightedList/WeightedListDemo.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Randomization/WeightedList/WeightedListDemo.cs","docFileContent":"### Weighted List\nThis is a simple data structure which creates a very basic probability distribution given multiple objects with different weights. In other words, you can use this to randomly pick items such that some items are picked more commonly than others.\n\nFor example, if you have 3 items with these weights:\n1. Gold: Weight of 1.\n2. Silver: Weight of 5.\n3. Copper: Weight of 20.\n\nThis means that you have a 20/26 chance of randomly picking Copper, a 5/26 chance of randomly picking Silver, and a 1/26 chance of randomly picking Gold.\n\nThis is helpful to use, for example, when generating random loot items where items have different rarities.\n\nThe Demo uses `GameObjects` to represent the items and their weights; this works well for Demo purposes but I recommend setting up `ScriptableObjects` for this purpose instead, as weighted items are better represented in such a form. Alternatively, weighted items can be pretty much anything as long as they define a `Weight`.\n","supportingFiles":[{"demoName":"WeightedList","fileContent":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\n\nnamespace FKUnitySnippets.Randomization\n{\n    [Serializable]\n    public class WeightedEntry<T>\n    {\n        public T Item { get; set; }\n\n        public float Weight = 1.0f;\n    }\n\n    public class WeightedList<T>\n    {\n        private List<WeightedEntry<T>> _entries = new();\n\n        private float _totalWeight;\n\n        public WeightedList(IEnumerable<WeightedEntry<T>> entries)\n        {\n            AddEntries(entries);\n        }\n\n        public void Clear()\n        {\n            _entries.Clear();\n        }\n\n        public void AddEntries(IEnumerable<WeightedEntry<T>> entries)\n        {\n            _entries.AddRange(entries);\n            _entries.Sort((a, b) => a.Weight.CompareTo(b.Weight));\n            _totalWeight = _entries.Sum(entry => entry.Weight);\n        }\n\n        /// <summary>\n        /// Applies the transform function to all weights in the list.\n        /// </summary>\n        /// <param name=\"transformFunction\"></param>\n        public void AdjustWeights(Func<float, float> transformFunction)\n        {\n            var totalWeight = 0.0f;\n            foreach (var entry in _entries)\n            {\n                entry.Weight = transformFunction(entry.Weight);\n                totalWeight += entry.Weight;\n            }\n\n            _totalWeight = totalWeight;\n        }\n\n        public T GetRandomItem()\n        {\n            if (_entries.Count == 0)\n            {\n                return default;\n            }\n\n            return GetRandom(_entries).Item;\n        }\n\n        /// <summary>\n        /// Note: this is a good method to have as an extension function in your project,\n        /// but I inlined it here to keep this code self-contained.\n        /// </summary>\n        private TValue GetRandom<TValue>(IList<TValue> list)\n        {\n            if (list == null || list.Count == 0)\n            {\n                return default;\n            }\n\n            var random = UnityEngine.Random.Range(0, list.Count);\n            return list[random];\n        }\n\n        public T GetWeightedRandomItem()\n        {\n            float randomWeightPoint = UnityEngine.Random.Range(0, _totalWeight);\n            float accumulatedWeight = 0;\n\n            foreach (var entry in _entries)\n            {\n                accumulatedWeight += entry.Weight;\n                if (accumulatedWeight >= randomWeightPoint)\n                {\n                    return entry.Item;\n                }\n            }\n\n            // fallback\n            Debug.LogWarning(\"No item was selected. This should not happen if the weights are set up correctly.\");\n            return GetRandomItem();\n        }\n    }\n}","name":"WeightedList","category":"Randomization","shortPath":"Randomization/WeightedList","filename":"WeightedList.cs","path":"Randomization/WeightedList/WeightedList.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Randomization/WeightedList/WeightedList.cs","docFileContent":null,"supportingFiles":[]}],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Randomization/WeightedList/WeightedList.unitypackage","packageFileName":"WeightedList.unitypackage"},{"demoName":"PerlinNoiseMap","fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Randomization\n{\n    public class PerlinNoiseMapDemo : MonoBehaviour\n    {\n        [SerializeField]\n        private GameObject _tilePrefab;\n\n        private Transform _tiles;\n\n        [SerializeField]\n        private int _mapWidth = 100;\n\n        [SerializeField]\n        private int _mapHeight = 100;\n\n        [SerializeField]\n        private float _scale = 1.0f;\n\n        [SerializeField]\n        private float _offsetX = 0.0f;\n\n        [SerializeField]\n        private float _offsetY = 0.0f;\n\n        [SerializeField]\n        private float _threshold = 0.5f;\n\n        private float[,] _map;\n\n        public void Generate()\n        {\n            _map = new PerlinNoiseMap(_mapWidth, _mapHeight, _scale, _offsetX, _offsetY).Map;\n\n            if (_tiles != null)\n            {\n                Destroy(_tiles.gameObject);\n            }\n\n            _tiles = new GameObject(\"Tiles\").transform;\n\n            for (var x = 0; x < _mapWidth; x++)\n            {\n                for (var y = 0; y < _mapWidth; y++)\n                {\n                    if (_map[x, y] < _threshold)\n                    {\n                        var tile = Instantiate(_tilePrefab, _tiles, true);\n                        tile.transform.localPosition = new Vector3(x, y, 0.0f);\n                    }\n                }\n            }\n\n            // this is here so that the tiles are deleted when switching to another demo\n            _tiles.SetParent(transform);\n\n            // NOTE: these transforms are just so that it fits nicely into the view for the demo\n            _tiles.position = new Vector3(-2.5f, -1.0f, 0.0f);\n            _tiles.localScale = new Vector3(0.05f, 0.05f, 1.0f);\n        }\n    }\n}","name":"PerlinNoiseMap","category":"Randomization","shortPath":"Randomization/PerlinNoiseMap","filename":"PerlinNoiseMapDemo.cs","path":"Randomization/PerlinNoiseMap/PerlinNoiseMapDemo.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Randomization/PerlinNoiseMap/PerlinNoiseMapDemo.cs","docFileContent":"### Perlin Noise Map\nPerlin Noise is a good tool to generate somewhat structured random data, and it's used quite a bit in game development for many things, as texture and fog effects (though this only scratches the surface).\n\nUnity has a built-in function to gather Perlin Noise: `Mathf.PerlinNoise`. This `PerlinNoiseMap` utility gives you some handy parameters to generate a 2D map of Perlin Noise which can be used for many things.\n\nIn the Demo example, I generate a 100x100 tile map based on threshold values of Perlin Noise. With some small bit of tweaking, you might see how this could be used to generate things like cave structures. Sky's the limit!\n\nPlay around with the various offset, threshold and scale values to see how you can generate slightly different structures.","supportingFiles":[{"demoName":"PerlinNoiseMap","fileContent":"using System.Collections.Generic;\nusing UnityEngine;\n\nnamespace FKUnitySnippets.Randomization\n{\n    public class PerlinNoiseMap\n    {\n        public float[,] Map { get; private set; }\n\n        public PerlinNoiseMap(int width, int height, float scale = 1.0f, float offsetX = 0.0f, float offsetY = 0.0f)\n        {\n            Map = GeneratePerlinMap(width, height, scale, offsetX, offsetY);\n        }\n\n        public static float[,] GeneratePerlinMap(int width, int height, float scale = 1.0f, float offsetX = 0.0f, float offsetY = 0.0f)\n        {\n            if (scale <= 0)\n            {\n                scale = 0.0001f;\n            }\n\n            float[,] map = new float[width, height];\n\n            for (int x = 0; x < width; x++)\n            {\n                for (int y = 0; y < height; y++)\n                {\n                    float sampleX = (x + offsetX) / scale;\n                    float sampleY = (y + offsetY) / scale;\n                    map[x, y] = Mathf.PerlinNoise(sampleX, sampleY);\n                }\n            }\n\n            return map;\n        }\n    }\n}","name":"PerlinNoiseMap","category":"Randomization","shortPath":"Randomization/PerlinNoiseMap","filename":"PerlinNoiseMap.cs","path":"Randomization/PerlinNoiseMap/PerlinNoiseMap.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Randomization/PerlinNoiseMap/PerlinNoiseMap.cs","docFileContent":null,"supportingFiles":[]}],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Randomization/PerlinNoiseMap/PerlinNoiseMap.unitypackage","packageFileName":"PerlinNoiseMap.unitypackage"}]