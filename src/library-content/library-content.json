[{"demoName":"ShakyText","fileContent":"using UnityEngine;\nusing System.Collections;\nusing TMPro;\n\nnamespace FKUnitySnippets.Text.TMPro\n{\n    /// <summary>\n    /// This is adapted from the VertexJitter script in the TextMesh Pro extensions\n    /// examples. This one allows for more configuration and allows the text to change\n    /// dynamically, and for the jitter effect to be started and stopped.\n    /// </summary>\n    [RequireComponent(typeof(TMP_Text))]\n    public class ShakyText : MonoBehaviour\n    {\n        [SerializeField]\n        private float _angleMultiplier = 1.0f;\n\n        [SerializeField]\n        private float _curveScale = 1.0f;\n\n        private TMP_Text _textComponent;\n\n        private bool hasTextChanged;\n\n        [SerializeField]\n        private bool _autoStart = false;\n\n        private Coroutine _jitterRoutine;\n\n        /// <summary>\n        /// Structure to hold pre-computed animation data.\n        /// </summary>\n        private struct VertexAnim\n        {\n            public float angleRange;\n            public float angle;\n            public float speed;\n        }\n\n        void Awake()\n        {\n            _textComponent = GetComponent<TMP_Text>();\n        }\n\n        void OnEnable()\n        {\n            // Subscribe to event fired when text object has been regenerated.\n            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);\n        }\n\n        void OnDisable()\n        {\n            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);\n        }\n\n\n        void Start()\n        {\n            if (_autoStart)\n            {\n                _jitterRoutine = StartCoroutine(AnimateVertexColors());\n            }\n        }\n\n        public void StartJitter()\n        {\n            if (!this.gameObject.activeInHierarchy)\n            {\n                return;\n            }\n\n            if (_jitterRoutine != null)\n            {\n                StopCoroutine(_jitterRoutine);\n            }\n\n            _jitterRoutine = StartCoroutine(AnimateVertexColors());\n        }\n\n        public void StopJitter()\n        {\n            if (_jitterRoutine == null)\n            {\n                return;\n            }\n\n            StopCoroutine(_jitterRoutine);\n            _jitterRoutine = null;\n        }\n\n\n        void ON_TEXT_CHANGED(Object obj)\n        {\n            if (obj == _textComponent)\n            {\n                hasTextChanged = true;\n            }\n        }\n\n        /// <summary>\n        /// Method to animate vertex colors of a TMP Text object.\n        /// </summary>\n        /// <returns></returns>\n        IEnumerator AnimateVertexColors()\n        {\n\n            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.\n            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.\n            _textComponent.ForceMeshUpdate();\n\n            TMP_TextInfo textInfo = _textComponent.textInfo;\n\n            Matrix4x4 matrix;\n\n            int loopCount = 0;\n            hasTextChanged = true;\n\n            // Create an Array which contains pre-computed Angle Ranges and Speeds for a bunch of characters.\n            VertexAnim[] vertexAnim = new VertexAnim[1024];\n            for (int i = 0; i < 1024; i++)\n            {\n                vertexAnim[i].angleRange = Random.Range(10f, 25f);\n                vertexAnim[i].speed = Random.Range(1f, 3f);\n            }\n\n            // Cache the vertex data of the text object as the Jitter FX is applied to the original position of the characters.\n            TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData();\n\n            while (true)\n            {\n                // Get new copy of vertex data if the text has changed.\n                if (hasTextChanged)\n                {\n                    // Update the copy of the vertex data for the text object.\n                    cachedMeshInfo = textInfo.CopyMeshInfoVertexData();\n\n                    hasTextChanged = false;\n                }\n\n                int characterCount = textInfo.characterCount;\n\n                // If No Characters then just yield and wait for some text to be added\n                if (characterCount == 0)\n                {\n                    yield return new WaitForSeconds(0.25f);\n                    continue;\n                }\n\n\n                for (int i = 0; i < characterCount; i++)\n                {\n                    TMP_CharacterInfo charInfo = textInfo.characterInfo[i];\n\n                    // Skip characters that are not visible and thus have no geometry to manipulate.\n                    if (!charInfo.isVisible)\n                        continue;\n\n                    // Retrieve the pre-computed animation data for the given character.\n                    VertexAnim vertAnim = vertexAnim[i];\n\n                    // Get the index of the material used by the current character.\n                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;\n\n                    // Get the index of the first vertex used by this text element.\n                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;\n\n                    // Get the cached vertices of the mesh used by this text element (character or sprite).\n                    Vector3[] sourceVertices = cachedMeshInfo[materialIndex].vertices;\n\n                    // Determine the center point of each character at the baseline.\n                    //Vector2 charMidBasline = new Vector2((sourceVertices[vertexIndex + 0].x + sourceVertices[vertexIndex + 2].x) / 2, charInfo.baseLine);\n                    // Determine the center point of each character.\n                    Vector2 charMidBasline = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2;\n\n                    // Need to translate all 4 vertices of each quad to aligned with middle of character / baseline.\n                    // This is needed so the matrix TRS is applied at the origin for each character.\n                    Vector3 offset = charMidBasline;\n\n                    Vector3[] destinationVertices = textInfo.meshInfo[materialIndex].vertices;\n\n                    destinationVertices[vertexIndex + 0] = sourceVertices[vertexIndex + 0] - offset;\n                    destinationVertices[vertexIndex + 1] = sourceVertices[vertexIndex + 1] - offset;\n                    destinationVertices[vertexIndex + 2] = sourceVertices[vertexIndex + 2] - offset;\n                    destinationVertices[vertexIndex + 3] = sourceVertices[vertexIndex + 3] - offset;\n\n                    vertAnim.angle = Mathf.SmoothStep(-vertAnim.angleRange, vertAnim.angleRange, Mathf.PingPong(loopCount / 25f * vertAnim.speed, 1f));\n                    Vector3 jitterOffset = new Vector3(Random.Range(-.25f, .25f), Random.Range(-.25f, .25f), 0);\n\n                    matrix = Matrix4x4.TRS(jitterOffset * _curveScale, Quaternion.Euler(0, 0, Random.Range(-5f, 5f) * _angleMultiplier), Vector3.one);\n\n                    destinationVertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 0]);\n                    destinationVertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 1]);\n                    destinationVertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 2]);\n                    destinationVertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 3]);\n\n                    destinationVertices[vertexIndex + 0] += offset;\n                    destinationVertices[vertexIndex + 1] += offset;\n                    destinationVertices[vertexIndex + 2] += offset;\n                    destinationVertices[vertexIndex + 3] += offset;\n\n                    vertexAnim[i] = vertAnim;\n                }\n\n                // Push changes into meshes\n                for (int i = 0; i < textInfo.meshInfo.Length; i++)\n                {\n                    textInfo.meshInfo[i].mesh.vertices = textInfo.meshInfo[i].vertices;\n                    _textComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);\n                }\n\n                loopCount += 1;\n\n                yield return new WaitForSeconds(0.1f);\n            }\n        }\n    }\n}","name":"ShakyText","category":"Text/TMPro","shortPath":"Text/TMPro/ShakyText","filename":"ShakyText.cs","path":"Text/TMPro/ShakyText/ShakyText.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Text/TMPro/ShakyText/ShakyText.cs","docFileContent":"### Shaky Text\nThis is a simple modification of Unity's own VertexJitter script which comes with the TMPro Extensions & Examples package. This modification makes it a bit easier to use for this purpose.","supportingFiles":[],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Text/TMPro/ShakyText/ShakyText.unitypackage","packageFileName":"ShakyText.unitypackage"},{"demoName":"OscillatingObject","fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Transformations\n{\n    public class OscillatingObject : MonoBehaviour\n    {\n        private float _period = 0.0f;\n\n        [SerializeField]\n        private float _speed = 1.0f;\n\n        [SerializeField]\n        private float _magnitude = 1.0f;\n\n        [SerializeField]\n        private Vector3 _axis = Vector3.up;\n\n        private Vector3 _originalPos;\n\n        public void ResetState()\n        {\n            this.transform.localPosition = _originalPos;\n            _period = 0.0f;\n        }\n\n        void Start()\n        {\n            _originalPos = this.transform.localPosition;\n        }\n\n        // Update is called once per frame\n        void Update()\n        {\n            _period = (_period + _speed * Time.deltaTime) % (2 * Mathf.PI);\n\n            var cos = Mathf.Abs(Mathf.Cos(_period) * _magnitude);\n            this.transform.localPosition = _originalPos + this._axis * cos;\n        }\n    }\n}","name":"OscillatingObject","category":"Transformations","shortPath":"Transformations/OscillatingObject","filename":"OscillatingObject.cs","path":"Transformations/OscillatingObject/OscillatingObject.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Transformations/OscillatingObject/OscillatingObject.cs","docFileContent":"### Oscillating Object\nUsing functions like *sin* or *cos* is a good way to make object \"wavering\" movement like this look smooth.","supportingFiles":[],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Transformations/OscillatingObject/OscillatingObject.unitypackage","packageFileName":"OscillatingObject.unitypackage"},{"demoName":"SpinningObject","fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Transformations\n{\n    public class SpinningObject : MonoBehaviour\n    {\n        [SerializeField]\n        private float _rotationSpeed = 1f;\n\n        [SerializeField]\n        private Vector3 _axis = Vector3.up;\n\n        private Quaternion _originalRotation;\n\n        private void Start()\n        {\n            _originalRotation = transform.rotation;\n        }\n\n        private void Update()\n        {\n            transform.Rotate(_axis, _rotationSpeed * Time.deltaTime);\n        }\n\n        public void ResetState()\n        {\n            transform.rotation = _originalRotation;\n        }\n    }\n}\n","name":"SpinningObject","category":"Transformations","shortPath":"Transformations/SpinningObject","filename":"SpinningObject.cs","path":"Transformations/SpinningObject/SpinningObject.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Transformations/SpinningObject/SpinningObject.cs","docFileContent":"### Spinning Object\nThis extremely simple script seems trivial, but it can be used creatively in many ways. See the various demos to see how you can:\n\n1. Make an object spin at variable speeds.\n2. Spin various objects around an object.\n3. Spin a 2D object around the Y axis to have a \"spinning coin\" effect common in 2D platformers.","supportingFiles":[],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Transformations/SpinningObject/SpinningObject.unitypackage","packageFileName":"SpinningObject.unitypackage"},{"demoName":"BezierDemo","fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Curves.Bezier\n{\n    public class BezierDemo : MonoBehaviour\n    {\n        [Tooltip(\"Which object is moving along the curve.\")]\n        [SerializeField]\n        private GameObject _targetObject;\n\n        [Tooltip(\"End point of the curve.\")]\n        [SerializeField]\n        private Vector3 _targetPoint;\n\n        [Tooltip(\"Starting point of the curve.\")]\n        [SerializeField]\n        private Vector3 _startingPoint;\n\n        [Tooltip(\"How far up (or down, if negative) the middle of the curve is.\")]\n        [SerializeField]\n        private float _controlPointOffset = 0.0f;\n\n        [Tooltip(\"Travel speed of object.\")]\n        [SerializeField]\n        private float _speed = 1.0f;\n\n        [Tooltip(\"If true, the object will rotate in the direction of movement.\")]\n        [SerializeField]\n        private bool _turnInMovementDirection = true;\n\n        [Tooltip(\"If true, the position will reset to the starting point when the target is reached.\")]\n        [SerializeField]\n        private bool _looping = true;\n\n        private float _t = 0.0f;\n\n        private Bezier _bezier;\n\n        private void Start()\n        {\n            ResetState();   \n        }\n\n        public void ResetState()\n        {\n            _t = 0.0f;\n            var midpoint = (_startingPoint + _targetPoint) / 2;\n            _bezier = new Bezier(_startingPoint, midpoint + Vector3.up * _controlPointOffset, _targetPoint);\n        }\n\n        public void Reverse()\n        {\n            _speed *= -1;\n        }\n\n        private void Update()\n        {\n            // this allows _speed to change to negative to reverse the direction\n            // after the destination is reached\n            var t = _t + Time.deltaTime * _speed;\n            if (t < 0.0f || t > 1.0f)\n            {\n                if (_looping)\n                {\n                    ResetState();\n                }\n\n                return;\n            }\n\n            _t = t;\n            var point = _bezier.GetPoint(_t);\n            _targetObject.transform.position = point;\n\n            if (_turnInMovementDirection)\n            {\n                Vector3 direction = _bezier.GetDirection(_t);\n                float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;\n                _targetObject.transform.rotation = Quaternion.Euler(new Vector3(0, 0, angle));\n\n                // NOTE: The following also works the same as above; however, due to how Quaternion.LookRotation works,\n                // it requires the additional rotation below to make it work properly in 2D.\n                // _targetObject.rotation = Quaternion.LookRotation(_bezier.GetDirection(_t));\n                // _targetObject.Rotate(0, 90, 180);\n            }\n        }\n    }\n}\n","name":"Bezier","category":"Curves/Bezier","shortPath":"Curves/Bezier","filename":"BezierDemo.cs","path":"Curves/Bezier/BezierDemo.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Curves/Bezier/BezierDemo.cs","docFileContent":"### Bezier Curves\nYou can use Bezier curves to represent an \"arc\", like an arrow shooting up and back down. You can get a similar parabolic effect by using physics and gravity, but Bezier curves are simple and effective ways to plot the trajectory of an object through an arc.\n\nThe basic things about the `Bezier.cs` script:\n\n1. The object goes from `_t` == 0.0f (start point) to `_t` == 1.0f (end point). The speed at which `_t` goes up indicates how quickly the object moves.\n2. There are 3 `Vector3` points defining the curve: `p0`, `p1` and `p2`. `p0` is the start point and `p2` is the end point. `p1` is some point in the middle that determines how far up or down the object will curve. It doesn't need to be at the midpoint between `p0` and `p2`, though this Demo script uses that to make a symmetrical arc.\n3. You can use the derivative of the arc to make the object point in the direction that it is facing. This Demo uses this to make the arrow point in the correct direction.","supportingFiles":[{"demoName":"Bezier","fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Curves.Bezier\n{\n    public class Bezier\n    {\n        private Vector3 p0;\n        private Vector3 p1;\n        private Vector3 p2;\n\n        public Bezier(Vector3 p0, Vector3 p1, Vector3 p2)\n        {\n            this.p0 = p0;\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n\n        public Vector3 GetPoint(float t)\n        {\n            t = Mathf.Clamp01(t);\n            float oneMinusT = 1.0f - t;\n            return oneMinusT * oneMinusT * p0 +\n                2f * oneMinusT * t * p1 +\n                t * t * p2;\n        }\n\n        public Vector3 GetFirstDerivative(float t)\n        {\n            return 2f * (1f - t) * (p1 - p0) + 2f * t * (p2 - p1);\n        }\n\n        public Vector3 GetVelocity(Transform transform, float t)\n        {\n            return transform.TransformPoint(this.GetFirstDerivative(t)) - transform.position;\n        }\n\n        public Vector3 GetDirection(Transform transform, float t)\n        {\n            return GetVelocity(transform, t).normalized;\n        }\n\n        public Vector3 GetDirection(float t)\n        {\n            return GetFirstDerivative(t).normalized;\n        }\n    }\n}","name":"Bezier","category":"Curves/Bezier","shortPath":"Curves/Bezier","filename":"Bezier.cs","path":"Curves/Bezier/Bezier.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Curves/Bezier/Bezier.cs","docFileContent":null,"supportingFiles":[]}],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Curves/Bezier/Bezier.unitypackage","packageFileName":"BezierDemo.unitypackage"},{"demoName":"WeightedListDemo","fileContent":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\nusing UnityEngine.UI;\n\nnamespace FKUnitySnippets.Probability\n{\n    [Serializable]\n    public class WeightedItem\n    {\n        public string Name;\n        public float Weight = 1.0f;\n        public Sprite Icon;\n    }\n\n    public class WeightedListDemo : MonoBehaviour\n    {\n        private WeightedList<WeightedItem> _weightedList;\n\n        [SerializeField]\n        private WeightedItem[] _items;\n\n        private LayoutGroup _resultDisplay;\n\n        private void Start()\n        {\n            var items = _items.Select(_items => new WeightedEntry<WeightedItem> { Item = _items, Weight = _items.Weight });\n            _weightedList = new WeightedList<WeightedItem>(items);\n\n            _resultDisplay = GetComponentInChildren<LayoutGroup>();\n        }\n\n        public void GenerateItems(bool weighted)\n        {\n            DestroyChildren(_resultDisplay.transform);\n            var items = new List<WeightedItem>();\n            for (var i = 0; i < 100; i++)\n            {\n                if (weighted)\n                {\n                    items.Add(_weightedList.GetWeightedRandomItem());\n                }\n                else\n                {\n                    items.Add(_weightedList.GetRandomItem());\n                }\n                \n            }\n\n            // sort by weight (ascending)\n            items.Sort((a, b) => (int)(a.Weight - b.Weight));\n\n            // add icons to the layout for the items being displayed\n            foreach (var item in items)\n            {\n                var itemObject = new GameObject(item.Name);\n                var image = itemObject.AddComponent<Image>();\n                image.sprite = item.Icon;\n                itemObject.transform.SetParent(_resultDisplay.transform);\n            }\n        }\n\n        public void DestroyChildren(Transform transform)\n        {\n            foreach (Transform child in transform)\n            {\n                if (child != null)\n                {\n                    UnityEngine.Object.Destroy(child.gameObject);\n                }\n            }\n        }\n    }\n}\n","name":"WeightedList","category":"Probability","shortPath":"Probability/WeightedList","filename":"WeightedListDemo.cs","path":"Probability/WeightedList/WeightedListDemo.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Probability/WeightedList/WeightedListDemo.cs","docFileContent":"### Wheighted List\nThis is a simple data structure which creates a very basic probability distribution given multiple objects with different weights. In other words, you can use this to randomly pick items such that some items are picked more commonly than others.\n\nFor example, if you have 3 items with these weights:\n1. Gold: Weight of 1.\n2. Silver: Weight of 5.\n3. Copper: Weight of 20.\n\nThis means that you have a 20/26 chance of randomly picking Copper, a 5/26 chance of randomly picking Silver, and a 1/26 chance of randomly picking Gold.\n\nThis is helpful to use, for example, when generating random loot items where items have different rarities.\n\nThe Demo uses `GameObjects` to represent the items and their weights; this works well for Demo purposes but I recommend setting up `ScriptableObjects` for this purpose instead, as weighted items are better represented in such a form. Alternatively, weighted items can be pretty much anything as long as they define a `Weight`.\n","supportingFiles":[{"demoName":"WeightedList","fileContent":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\n\nnamespace FKUnitySnippets.Probability\n{\n    [Serializable]\n    public class WeightedEntry<T>\n    {\n        public T Item { get; set; }\n\n        public float Weight = 1.0f;\n    }\n\n    public class WeightedList<T>\n    {\n        private List<WeightedEntry<T>> _entries = new();\n\n        private float _totalWeight;\n\n        public WeightedList(IEnumerable<WeightedEntry<T>> entries)\n        {\n            AddEntries(entries);\n        }\n\n        public void Clear()\n        {\n            _entries.Clear();\n        }\n\n        public void AddEntries(IEnumerable<WeightedEntry<T>> entries)\n        {\n            _entries.AddRange(entries);\n            _entries.Sort((a, b) => a.Weight.CompareTo(b.Weight));\n            _totalWeight = _entries.Sum(entry => entry.Weight);\n        }\n\n        /// <summary>\n        /// Applies the transform function to all weights in the list.\n        /// </summary>\n        /// <param name=\"transformFunction\"></param>\n        public void AdjustWeights(Func<float, float> transformFunction)\n        {\n            var totalWeight = 0.0f;\n            foreach (var entry in _entries)\n            {\n                entry.Weight = transformFunction(entry.Weight);\n                totalWeight += entry.Weight;\n            }\n\n            _totalWeight = totalWeight;\n        }\n\n        public T GetRandomItem()\n        {\n            if (_entries.Count == 0)\n            {\n                return default;\n            }\n\n            return GetRandom(_entries).Item;\n        }\n\n        /// <summary>\n        /// Note: this is a good method to have as an extension function in your project,\n        /// but I inlined it here to keep this code self-contained.\n        /// </summary>\n        private TValue GetRandom<TValue>(IList<TValue> list)\n        {\n            if (list == null || list.Count == 0)\n            {\n                return default;\n            }\n\n            var random = UnityEngine.Random.Range(0, list.Count);\n            return list[random];\n        }\n\n        public T GetWeightedRandomItem()\n        {\n            float randomWeightPoint = UnityEngine.Random.Range(0, _totalWeight);\n            float accumulatedWeight = 0;\n\n            foreach (var entry in _entries)\n            {\n                accumulatedWeight += entry.Weight;\n                if (accumulatedWeight >= randomWeightPoint)\n                {\n                    return entry.Item;\n                }\n            }\n\n            // fallback\n            Debug.LogWarning(\"No item was selected. This should not happen if the weights are set up correctly.\");\n            return GetRandomItem();\n        }\n    }\n}","name":"WeightedList","category":"Probability","shortPath":"Probability/WeightedList","filename":"WeightedList.cs","path":"Probability/WeightedList/WeightedList.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Probability/WeightedList/WeightedList.cs","docFileContent":null,"supportingFiles":[]}],"packageFileUrl":"https://raw.githubusercontent.com/Flavkupe/FKUnitySnippetsLibrary/main/FKUnitySnippetsLibrary/Probability/WeightedList/WeightedList.unitypackage","packageFileName":"WeightedListDemo.unitypackage"}]