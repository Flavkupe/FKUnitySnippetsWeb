[{"fileContent":"using UnityEngine;\nusing System.Collections;\nusing TMPro;\n\nnamespace FKUnitySnippets.Text.TMPro\n{\n    /// <summary>\n    /// This is adapted from the VertexJitter script in the TextMesh Pro extensions\n    /// examples. This one allows for more configuration and allows the text to change\n    /// dynamically, and for the jitter effect to be started and stopped.\n    /// </summary>\n    [RequireComponent(typeof(TMP_Text))]\n    public class ShakyText : MonoBehaviour\n    {\n        [SerializeField]\n        public float _angleMultiplier = 1.0f;\n\n        [SerializeField]\n        public float _speedMultiplier = 1.0f;\n\n        [SerializeField]\n        public float _curveScale = 1.0f;\n\n        private TMP_Text _textComponent;\n\n        private bool hasTextChanged;\n\n        [SerializeField]\n        private bool _autoStart = false;\n\n        private Coroutine _jitterRoutine;\n\n        /// <summary>\n        /// Structure to hold pre-computed animation data.\n        /// </summary>\n        private struct VertexAnim\n        {\n            public float angleRange;\n            public float angle;\n            public float speed;\n        }\n\n        void Awake()\n        {\n            _textComponent = GetComponent<TMP_Text>();\n        }\n\n        void OnEnable()\n        {\n            // Subscribe to event fired when text object has been regenerated.\n            TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);\n        }\n\n        void OnDisable()\n        {\n            TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);\n        }\n\n\n        void Start()\n        {\n            if (_autoStart)\n            {\n                _jitterRoutine = StartCoroutine(AnimateVertexColors());\n            }\n        }\n\n        public void StartJitter()\n        {\n            if (!this.gameObject.activeInHierarchy)\n            {\n                return;\n            }\n\n            if (_jitterRoutine != null)\n            {\n                StopCoroutine(_jitterRoutine);\n            }\n\n            _jitterRoutine = StartCoroutine(AnimateVertexColors());\n        }\n\n        public void StopJitter()\n        {\n            if (_jitterRoutine == null)\n            {\n                return;\n            }\n\n            StopCoroutine(_jitterRoutine);\n            _jitterRoutine = null;\n        }\n\n\n        void ON_TEXT_CHANGED(Object obj)\n        {\n            if (obj == _textComponent)\n            {\n                hasTextChanged = true;\n            }\n        }\n\n        /// <summary>\n        /// Method to animate vertex colors of a TMP Text object.\n        /// </summary>\n        /// <returns></returns>\n        IEnumerator AnimateVertexColors()\n        {\n\n            // We force an update of the text object since it would only be updated at the end of the frame. Ie. before this code is executed on the first frame.\n            // Alternatively, we could yield and wait until the end of the frame when the text object will be generated.\n            _textComponent.ForceMeshUpdate();\n\n            TMP_TextInfo textInfo = _textComponent.textInfo;\n\n            Matrix4x4 matrix;\n\n            int loopCount = 0;\n            hasTextChanged = true;\n\n            // Create an Array which contains pre-computed Angle Ranges and Speeds for a bunch of characters.\n            VertexAnim[] vertexAnim = new VertexAnim[1024];\n            for (int i = 0; i < 1024; i++)\n            {\n                vertexAnim[i].angleRange = Random.Range(10f, 25f);\n                vertexAnim[i].speed = Random.Range(1f, 3f);\n            }\n\n            // Cache the vertex data of the text object as the Jitter FX is applied to the original position of the characters.\n            TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData();\n\n            while (true)\n            {\n                // Get new copy of vertex data if the text has changed.\n                if (hasTextChanged)\n                {\n                    // Update the copy of the vertex data for the text object.\n                    cachedMeshInfo = textInfo.CopyMeshInfoVertexData();\n\n                    hasTextChanged = false;\n                }\n\n                int characterCount = textInfo.characterCount;\n\n                // If No Characters then just yield and wait for some text to be added\n                if (characterCount == 0)\n                {\n                    yield return new WaitForSeconds(0.25f);\n                    continue;\n                }\n\n\n                for (int i = 0; i < characterCount; i++)\n                {\n                    TMP_CharacterInfo charInfo = textInfo.characterInfo[i];\n\n                    // Skip characters that are not visible and thus have no geometry to manipulate.\n                    if (!charInfo.isVisible)\n                        continue;\n\n                    // Retrieve the pre-computed animation data for the given character.\n                    VertexAnim vertAnim = vertexAnim[i];\n\n                    // Get the index of the material used by the current character.\n                    int materialIndex = textInfo.characterInfo[i].materialReferenceIndex;\n\n                    // Get the index of the first vertex used by this text element.\n                    int vertexIndex = textInfo.characterInfo[i].vertexIndex;\n\n                    // Get the cached vertices of the mesh used by this text element (character or sprite).\n                    Vector3[] sourceVertices = cachedMeshInfo[materialIndex].vertices;\n\n                    // Determine the center point of each character at the baseline.\n                    //Vector2 charMidBasline = new Vector2((sourceVertices[vertexIndex + 0].x + sourceVertices[vertexIndex + 2].x) / 2, charInfo.baseLine);\n                    // Determine the center point of each character.\n                    Vector2 charMidBasline = (sourceVertices[vertexIndex + 0] + sourceVertices[vertexIndex + 2]) / 2;\n\n                    // Need to translate all 4 vertices of each quad to aligned with middle of character / baseline.\n                    // This is needed so the matrix TRS is applied at the origin for each character.\n                    Vector3 offset = charMidBasline;\n\n                    Vector3[] destinationVertices = textInfo.meshInfo[materialIndex].vertices;\n\n                    destinationVertices[vertexIndex + 0] = sourceVertices[vertexIndex + 0] - offset;\n                    destinationVertices[vertexIndex + 1] = sourceVertices[vertexIndex + 1] - offset;\n                    destinationVertices[vertexIndex + 2] = sourceVertices[vertexIndex + 2] - offset;\n                    destinationVertices[vertexIndex + 3] = sourceVertices[vertexIndex + 3] - offset;\n\n                    vertAnim.angle = Mathf.SmoothStep(-vertAnim.angleRange, vertAnim.angleRange, Mathf.PingPong(loopCount / 25f * vertAnim.speed, 1f));\n                    Vector3 jitterOffset = new Vector3(Random.Range(-.25f, .25f), Random.Range(-.25f, .25f), 0);\n\n                    matrix = Matrix4x4.TRS(jitterOffset * _curveScale, Quaternion.Euler(0, 0, Random.Range(-5f, 5f) * _angleMultiplier), Vector3.one);\n\n                    destinationVertices[vertexIndex + 0] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 0]);\n                    destinationVertices[vertexIndex + 1] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 1]);\n                    destinationVertices[vertexIndex + 2] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 2]);\n                    destinationVertices[vertexIndex + 3] = matrix.MultiplyPoint3x4(destinationVertices[vertexIndex + 3]);\n\n                    destinationVertices[vertexIndex + 0] += offset;\n                    destinationVertices[vertexIndex + 1] += offset;\n                    destinationVertices[vertexIndex + 2] += offset;\n                    destinationVertices[vertexIndex + 3] += offset;\n\n                    vertexAnim[i] = vertAnim;\n                }\n\n                // Push changes into meshes\n                for (int i = 0; i < textInfo.meshInfo.Length; i++)\n                {\n                    textInfo.meshInfo[i].mesh.vertices = textInfo.meshInfo[i].vertices;\n                    _textComponent.UpdateGeometry(textInfo.meshInfo[i].mesh, i);\n                }\n\n                loopCount += 1;\n\n                yield return new WaitForSeconds(0.1f);\n            }\n        }\n    }\n}","name":"ShakyText","shortPath":"Text/TMPro","filename":"ShakyText.cs","path":"FKUnitySnippetsLibrary/Text/TMPro/ShakyText.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Text/TMPro/ShakyText.cs"},{"fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Transformations\n{\n    public class OscillatingObject : MonoBehaviour\n    {\n        private float _period = 0.0f;\n\n        [SerializeField]\n        private float _speed = 1.0f;\n\n        [SerializeField]\n        private float _magnitude = 1.0f;\n\n        [SerializeField]\n        private Vector3 _axis = Vector3.up;\n\n        private Vector3 _originalPos;\n\n        void Start()\n        {\n            _originalPos = this.transform.localPosition;\n        }\n\n        // Update is called once per frame\n        void Update()\n        {\n            _period = (_period + _speed * Time.deltaTime) % (2 * Mathf.PI);\n\n            var cos = Mathf.Abs(Mathf.Cos(_period) * _magnitude);\n            this.transform.localPosition = _originalPos + this._axis * cos;\n        }\n    }\n}","name":"OscillatingObject","shortPath":"Transformations","filename":"OscillatingObject.cs","path":"FKUnitySnippetsLibrary/Transformations/OscillatingObject.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Transformations/OscillatingObject.cs"},{"fileContent":"using UnityEngine;\n\nnamespace FKUnitySnippets.Transformations\n{\n    public class SpinningObject : MonoBehaviour\n    {\n        [SerializeField]\n        private float _rotationSpeed = 1f;\n\n        [SerializeField]\n        private Vector3 _axis = Vector3.up;\n\n        private void Update()\n        {\n            transform.Rotate(_axis, _rotationSpeed * Time.deltaTime);\n        }\n    }\n}\n","name":"SpinningObject","shortPath":"Transformations","filename":"SpinningObject.cs","path":"FKUnitySnippetsLibrary/Transformations/SpinningObject.cs","url":"https://github.com/Flavkupe/FKUnitySnippetsLibrary/blob/main/FKUnitySnippetsLibrary/Transformations/SpinningObject.cs"}]